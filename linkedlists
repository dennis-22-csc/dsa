LinkedLists
If you are creating a music player app, what data structure should you use to store the music?
The most recommended is a linkedlist.
How is it possible that you can navigate back and forth pages in a web browser?
It is because navigation is implemented using linkedlists.
In some applications that allows you to undo actions you've taken, what data structure makes this possible?
Linkedlists.
If you want to implement the stack and queue data structures, how do you go about it?
Linkedlists.
What is a linkedlist and why is it suitable for these scenarios?
A linkedlist is a data structrure existing as nodes.
So when a linkedlist is talked about, imagine nodes.
What is a node?
A node is a point in a diagram at which lines intersect or branch.
Nodes are best visualized by a diagram.
When you're struggling to conceptualize a node, just draw a diagram.
Now, if you're asked to implement a linkedlist, you can be simplify the task as being asked to implement nodes.
But you should understand that this simplification is in conflict with another data structure called a tree data structure.
A tree also exists as nodes. You can as well conceptualize nodes when conceptualizing a tree data structure.
How can you differentiate a tree from a linkedlist?
Both consists of nodes, in both, nodes are connected to each other. But in a tree, some nodes branch of to give birth to standalone nodesthat will be connected to eachother but not to the siblings of their parent node.
All these are best captured using a diagram.
Now that we know what a linkedlist is, do linkedlists exists in different categories of there is only one type of linkedlist?
Well, linkedlists exists in various categories. But there are three common among us. 
The first is a singly linkedlist.
A singly linkedlist is a linkedlist implemented such that the nodes only connects in one direction (forward or backward). This is also best visualize using a diagram.
The second is a doubly linkedlist.
A doubly linkedlist is a linkedlist implemented such that the nodes connects  in two directions (forward and backward). This is best visualized using a diagram.
The third is a circular linkedlist.
A circular linkedlist is a linkedlist such that the last node in the list connects back to the first node in the list. This is best visualized using a diagram.
While you can easily google for codes implementing a linkedlist, it's still good to understand how to implement one. You would learn one or two new things about the computer in the process.
So next, we will look at how to implement a singly linkedlist in python.

Singly linked list
It has been said that a singly linkedlist is a linkedlist implemented such that the nodes only connects in one direction (forward or 
backward).  
To implement a singly linkedlist, we need to solve two major problems:
1. How to implement a node
2. How to implement the connections.
What is a node and how can it be implemented?
While it has been said that a node is a point in a diagram at which lines intersect or branch, we will reconceptualize a node as data in a diagram connected together by connecting lines. These connecting lines could be forward and/or backward.
How do we implement a node?
To implement a node, we need to think of the data we want to store as nodes. 
Do we want to store integers as nodes? Or string as nodes? Or objects as nodes?
We could as well store multiple individual data as nodes.
In solving the programming problem we want to solve, we will likely know what data we want to store as nodes.
Let's assume we will be storing integers as nodes, the next thing we need to do is create a Node class and declare a property of type int.
Since python is not typed, we will just declare a property. 
Once we've done that, we now have a class we can use to construct node objects that would be connected together by an imaginary connecting lines.
The below codes creates a Node class

# Create class Node
class Node:
    def __init__(self, data):
        self.data = data

# Tester codes
node = Node(20) # Create node object
print(node.data) # Print data in node object

node = Node(70) # Create node object
print(node.data) # Print data in node object

node = Node(10) # Create node object
print(node.data) # Print data in node object

node = Node(50) # Create node object
print(node.data) # Print data in node object

node = Node(90) # Create node object
print(node.data) # Print data in node object

Tester codes were included for the purpose of testing the class.
In the tester codes, you can see that five node objects were created and the data in each node were printed.

For the purpose of creating a singly linkedlist, we've solved the problem of implementing a node. The next challenge to be tackcled is the problem of connecting the nodes. How do we implement the connection?
How do we connect the five node objects we created so that they make up a linkedlist?
Because at the moment, they are just individual isolated nodes.

To implement the connection of nodes in a singly linkedlist, we introduce the concept of references traditionally known as the concept of pointers.
The idea is that if we want to connect node A to node B, it means we want to draw an imaginary line that will take us from node A to node B. What we need to achieve this is for us to store the address of node B alongside the data of node A so that when we are accessing the data of node A, we can also access the address of node B and use the address to locate node B.
The address of an object is usually called a reference or a pointer.

To implement the connection of nodes, we will need to modify the Node class so that the address of the next node to be accessed will be a property in the current node.  What name can we give to this property? We can give it the name next_node.

The codes have been modified to the below:

# Create class Node
class Node:
    def __init__(self, data, next_node):
        self.data = data
        self.next_node = next_node

# Tester codes
node5 = Node(20, None) # Create node object
print(node5.data) # Print data in node object
print(node5.next_node) # Print address of next node object

node4 = Node(70, node5) # Create node object
print(node4.data) # Print data in node object
print(node4.next_node) # Print address of next node object

node3 = Node(10, node4) # Create node object
print(node3.data) # Print data in node object
print(node3.next_node) # Print address of next node object

node2 = Node(50, node3) # Create node object
print(node2.data) # Print data in node object
print(node2.next_node) # Print address of next node object

node1 = Node(90, node2) # Create node object
print(node1.data) # Print data in node object
print(node1.next_node) # Print address of next node object

If you look at how the tester codes were modified, you will see that the first data to be stored was stored in the last node which is the fifth node. This is necessary because if it is stored in the first node, we won't be able to pass alongside the data the address of the next node. This is because the next node has not been created yet. We can't create the next node (second node) without creating the third node. So, the logical way to implement the connection is to store the first data in the fifth node.
 
At this point, we've implemented a node and we've also modified the node such that it will include a reference to the next node, next, we need to create a LinkedList object.
This object is an object that will comprise of node objects each of which contains data and a reference to the next node in the list.
The LinkedList object will have an add method that will be used to add data(nodes) to the list. Internally in the add method, the address of the next node will be stored alongside the data of the current node.

Creating a LinkedList class is not hard. Creating the add method is what is hard. But how can we define such a method? How will the method work? Let's iron out the details.
The method will take a value as an argument, then internally, it will create a Node object and insert that value in the Node object.
Now, the first time this method is called, the value None should be specified as the value of the next_node property of the Node object.
Subsequent time this method is called, a value should be passed. 
How then do we code the method?
Well, we can introduce a count variable that will be incremented by 1 each time the add method is called. If the count is less than or equal to 1, the value None should be specified as the value of the next_node property, else, a value should be provided. Problem solved.

# Create class Node
class Node:
    def __init__(self, data, next_node):
        self.data = data
        self.next_node = next_node

# Create class SinglyLinkedList
class SinglyLinkedList:
    def __init__(self):
        self.node = None
        self.count = 0

    def add(self, node_data):
        self.count += 1
        if self.count <= 1:
            self.node = Node(node_data, None)
        else:
            self.node = Node(node_data, self.node)

# Tester codes
mylist = SinglyLinkedList()
mylist.add(20)
mylist.add(90)
mylist.add(40)
mylist.add(10)

print(mylist.node.data)
print(mylist.node.next_node)

Problem looked to be solved, except that we can iterate through the list and print out its element, we can't also use index to access elements in the list.
Based on the current implementation, we can only access the first node. But remember, the first_node contains the address of the next_node, can we use that to access all the nodes up to the last node?
Let's see. 

Well, I was able to:

# Create class Node
class Node:
    def __init__(self, data, next_node):
        self.data = data
        self.next_node = next_node

# Create class SinglyLinkedList
class SinglyLinkedList:
    def __init__(self):
        self.node = None
        self.count = 0

    def add(self, node_data):
        self.count += 1
        if self.count <= 1:
            self.node = Node(node_data, None)
        else:
            self.node = Node(node_data, self.node)

# Tester codes
mylist = SinglyLinkedList()
mylist.add(20)
mylist.add(90)
mylist.add(40)
mylist.add(10)

print(mylist.node.data)

node2 = mylist.node.next_node
print(node2.data)

node3 = node2.next_node
print(node3.data)

node4 = node3.next_node
print(node4.data)

Let's see how we can make the SinglyLinkedList class iterable and indexable.

# Create class Node
class Node:
    def __init__(self, data, next_node):
        self.data = data
        self.next_node = next_node

# Create class SinglyLinkedList
class SinglyLinkedList:
    def __init__(self):
        self.node = None
        self.current_node = None
        self.count = 0

    def add(self, node_data):
        self.count += 1
        if self.count <= 1:
            self.node = Node(node_data, None)
        else:
            self.node = Node(node_data, self.node)

    def __iter__(self):
        self.current_node = self.node
        return self

    def __next__(self):
        if self.current_node is None:
            raise StopIteration

        data = self.current_node.data
        self.current_node = self.current_node.next_node
        return data

    def __getitem__(self, index):
        if index < 0 or index >= self.count:
            raise IndexError("Index out of range")

        current_node = self.node
        for _ in range(index):
            current_node = current_node.next_node

        return current_node.data

# Tester codes
mylist = SinglyLinkedList()
mylist.add(20)
mylist.add(90)
mylist.add(40)
mylist.add(10)

# Test that the list is iterable
for i in mylist:
    print(i)

# Test that the list is indexable
print(mylist[3])

# Test that an index out of range exception will be thrown
print(mylist[4])


Implementing the __iter__() and __next__() methods makes the list iterable, while implementing the  __getitem__() method makes the list items accessible using index, that is indexable.







































